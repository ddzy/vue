<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>demo</title>
    <!-- Delete ".min" for console warnings in development -->
    <script src="../../dist/vue.js"></script>
    <style>
      html,
      body {
        height: 100%;
      }
      body,
      ul,
      li,
      p {
        margin: 0;
        padding: 0;
        list-style: none;
      }
      #wrapper {
        position: relative;
        width: 800px;
        margin: 0 auto;
      }
      img {
        position: absolute;
        transition: opacity 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <template id="appComponent">
      <div v-if="flag"></div>
    </template>

    <div id="router-demo">
      <div>
        <a class="router-item" data-path="/home">/home</a>
        <a class="router-item" data-path="/about">/about</a>
        <a class="router-item" data-path="/category">/category</a>
      </div>
      <button onclick="router.go(-1)">go</button>
      <button onclick="router.forward()">forward</button>
      <button onclick="router.back()">back</button>
    </div>
  </body>
  <script>
    const AppComponent = Vue.component("AppComponent", {
      template: "#appComponent",
      props: {
        flag: {
          type: Boolean,
          required: true,
        },
      },
    });
    const AppComponent2 = Vue.component("AppComponent2", {
      render(h) {
        return h(
          "div",
          {
            class: "app-2-container",
          },
          "5678"
        );
      },
    });
    const app = new Vue({
      el: "#app",
      template: `
        <div class="container">
          <app-component :flag="flag"></app-component>
          <button @click="flag = !flag">Toggle flag</button>
        </div>
      `,
      components: {
        AppComponent,
      },
      data() {
        return {
          firstName: "zhaoyang",
          lastName: "duan",
          flag: false,
        };
      },
      computed: {
        computedFlag() {
          return this.flag ? 1 : 0;
        },
        computedName() {
          return `${this.lastName} ${this.firstName}`;
        },
      },
    });
  </script>
  <script>
    // const vm = new Vue({
    //   el: ".wrapper",
    //   data() {
    //     return {
    //       data: this.getData(),
    //       screenHeight: window.innerHeight,
    //       positions: [],
    //       scrollTop: 0,

    //       initialItemHeight: 100,
    //     };
    //   },
    //   computed: {
    //     computedWrapper() {
    //       return this.$refs.wrapperRef;
    //     },
    //     computedList() {
    //       return this.$refs.listRef;
    //     },
    //     computedGhost() {
    //       return this.$refs.ghostRef;
    //     },
    //     computedItems() {
    //       return this.computedList ? this.computedList.children : [];
    //     },
    //     computedItemContents() {
    //       return this.computedList.querySelectorAll("p");
    //     },
    //     computedGhostHeight() {
    //       return this.positions[this.positions.length - 1].bottom;
    //     },
    //     computedStartIndex() {
    //       if (this.scrollTop === 0) {
    //         return 0;
    //       }
    //       const foundStart = this.positions.find(
    //         (v) => this.scrollTop >= v.bottom
    //       );
    //       return foundStart ? foundStart.index : 0;
    //     },
    //     computedEndIndex() {
    //       const foundEnd = this.positions.find(
    //         (v) =>
    //           v.bottom - this.positions[this.computedStartIndex].bottom >=
    //           this.screenHeight
    //       );

    //       return foundEnd ? foundEnd.index : 0;
    //     },
    //     computedFinalData() {
    //       return this.data.slice(
    //         this.computedStartIndex,
    //         this.computedEndIndex + 1
    //       );
    //     },
    //   },
    //   watch: {
    //     computedStartIndex(newStartIndex) {
    //       console.log("newStartIndex :>> ", newStartIndex);
    //     },
    //     computedEndIndex(newEndIndex) {
    //       console.log("newEndIndex :>> ", newEndIndex);
    //     },
    //   },
    //   methods: {
    //     getData() {
    //       const data = [];

    //       for (let i = 0; i < 1000; i++) {
    //         data.push({
    //           _id: i,
    //           value: `${i}-${String(i).repeat(
    //             Math.random() * (1000 - 800) + 50
    //           )}`,
    //         });
    //       }
    //       return data;
    //     },
    //     updatePositions() {
    //       [...this.computedItems].forEach((v) => {
    //       const index = Number(v.getAttribute("id"));
    //       const rect = v.getBoundingClientRect();
    //       const prevIndex = index - 1 < 0 ? 0 : index - 1;

    //       console.log('prevIndex :>> ', prevIndex);

    //       this.positions[index] = {
    //         ...this.positions[index],
    //         height: rect.height,
    //         // 上一个列表项的 bottom + 当前列表项的高度
    //         bottom: rect.bottom + this.positions[prevIndex].bottom,
    //         top: this.positions[prevIndex].bottom,
    //       };
    //     });
    //     },
    //   },
    //   created() {
    //     this.positions = this.data.map((v, index) => ({
    //       index,
    //       height: this.initialItemHeight,
    //       bottom: (index + 1) * this.initialItemHeight,
    //       top: index * this.initialItemHeight,
    //     }));
    //   },
    //   mounted() {
    //     this.computedWrapper.addEventListener("scroll", (e) => {
    //       this.scrollTop = e.currentTarget.scrollTop;
    //     });
    //     this.updatePositions();
    //   },
    //   updated() {
    //     this.updatePositions();
    //   },
    // });
  </script>
  <script>
    // const list = document.getElementById("list");
    // const wrapper = document.querySelector(".wrapper");
    // const ghost = document.querySelector("#ghost");
    // const content = document.querySelector(".item-content");

    // const data = getData();
    // // 每一项的预估高度
    // const itemHeight = 100;
    // // 可视区域的高度
    // const screenHeight = window.innerHeight;
    // // 每次渲染多少个
    // const groupSize = Math.ceil(screenHeight / itemHeight);
    // // 起始位置
    // let startIndex = 0;
    // // 最终位置
    // let endIndex =
    //   startIndex + groupSize <= data.length
    //     ? startIndex + groupSize - 1
    //     : data.length - 1;
    // // 存储列表每一项的真实高度
    // const positions = data.map((v, index) => {
    //   return {
    //     index,
    //     height: itemHeight,
    //     top: index * itemHeight,
    //     bottom: (index + 1) * itemHeight,
    //   };
    // });

    // function getData() {
    //   const data = [];

    //   for (let i = 0; i < 1000; i++) {
    //     data.push({
    //       _id: i,
    //       value: `${i}-${String(i).repeat(Math.random() * (1000 - 800) + 50)}`,
    //     });
    //   }
    //   return data;
    // }
    // function throttle(callback, timestamp) {
    //   let prevTime = Date.now();
    //   return function (...args) {
    //     let currentTime = Date.now();
    //     if (currentTime - prevTime >= timestamp) {
    //       callback.apply(this, args);
    //       prevTime = currentTime;
    //     }
    //   };
    // }
    // function render(start, end) {
    //   if (positions.length !== data.length) {
    //     // 把已经渲染出来的列表项的位置大小信息缓存起来
    //     const children = list.querySelectorAll(".item-content");
    //     for (let i = 0; i < children.length; i++) {
    //       const dom = children[i];
    //       const rect = dom.getBoundingClientRect();
    //       const pos = Number(dom.getAttribute("id"));
    //       positions[pos] = {
    //         ...positions[pos],
    //         height: rect.height,
    //         top: rect.top,
    //         bottom: rect.bottom,
    //       };
    //     }
    //   }

    //   const div = document.createElement("div");
    //   for (let i = start; i <= end; i++) {
    //     const li = document.createElement("li");
    //     const p = document.createElement("p");
    //     li.appendChild(p);
    //     li.setAttribute("id", data[i]._id);
    //     li.classList.add("item");
    //     p.classList.add("item-content");
    //     p.textContent = data[i].value;
    //     li.style.cssText += `height: ${positions[i] ? "auto" : itemHeight}px`;
    //     div.appendChild(li);
    //   }
    //   list.innerHTML = div.innerHTML;
    // }

    // // 第一次渲染
    // render(startIndex, endIndex);
    // // 监听滚动，滚动时动态计算起始和结束位置
    // wrapper.addEventListener("scroll", throttle(handleScroll, 10));

    // function handleScroll(e) {
    //   const scrollTop = this.scrollTop;
    //   // startIndex = Math.ceil(scrollTop / itemHeight);
    //   // endIndex =
    //   //   startIndex + groupSize <= data.length
    //   //     ? startIndex + groupSize - 1
    //   //     : data.length - 1;

    //   let newStartIndex = positions.find((v) => v.top <= 0);
    //   let newEndIndex = positions.find((v) => v.bottom <= 0);
    //   startIndex = newStartIndex ? newStartIndex.index + 1 : 0;
    //   endIndex = newEndIndex ? newEndIndex.index + 1 : 10;

    //   render(startIndex, endIndex);

    //   // 重新计算渲染区域的位置，避免被顶到上面去
    //   list.style.cssText += `
    //     transform: translate3d(0, ${scrollTop}px, 0)
    //   `;
    // }
  </script>
  <script>
    // 懒加载
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: this.fetchData(),
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const result = [];

    //       for (let i = 0; i < 50; i++) {
    //         result.push({
    //           _id: i,
    //           src: `http://iph.href.lu/100x100?text=${i}`,
    //           dataSrc:
    //             "https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg",
    //           width: 100,
    //           height: 100,
    //         });
    //       }

    //       return result;
    //     },
    //   },
    //   mounted() {
    //     const imgs = this.$refs.imgRef;
    //     const io = new IntersectionObserver(
    //       (entries) => {
    //         entries.forEach((entry) => {
    //           if (entry.isIntersecting) {
    //             entry.target.setAttribute(
    //               "src",
    //               entry.target.getAttribute("data-src")
    //             );
    //           }
    //         });
    //       },
    //       {
    //         threshold: 0.5,
    //       }
    //     );

    //     imgs.forEach((v) => {
    //       io.observe(v);
    //     });
    //   },
    // });
  </script>
  <script>
    // 瀑布流
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: [],
    //       width: 150, // 固定宽度
    //       gap: 10, // 间隔
    //       columns: 1, // 列数
    //       columnsHeight: [], // 存储每一列的高度
    //       loadedImgCount: 0, // 记录当前已经加载完成的图片数量
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const data = [];

    //       for (let i = 0; i < 50; i++) {
    //         const height = Math.floor(Math.random() * (400 - 100) + 100);
    //         data.push({
    //           _id: i,
    //           src: `http://iph.href.lu/${this.width}x${height}?text=${i}`,
    //           width: this.width,
    //           height: 0,
    //           left: 0,
    //           top: 0,
    //           opacity: 0,
    //         });
    //       }

    //       return data;
    //     },
    //     imageLoaded(e) {
    //       this.loadedImgCount += 1;

    //       const img = e.target;
    //       const imgRect = img.getBoundingClientRect();
    //       const imgIndex = +img.dataset.index;

    //       // 第一行
    //       if (this.loadedImgCount <= this.columns) {
    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap,
    //           left: (this.width + this.gap) * (this.loadedImgCount - 1),
    //           opacity: 1,
    //         });
    //         this.columnsHeight[this.loadedImgCount - 1] =
    //           this.gap + imgRect.height;
    //       } else {
    //         // 其余行
    //         // 寻找最短的一列插入
    //         const minColumnHeight = Math.min(...this.columnsHeight);
    //         const minColumnIndex = this.columnsHeight.findIndex(
    //           (v) => v === minColumnHeight
    //         );

    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap + minColumnHeight,
    //           left: (this.width + this.gap) * minColumnIndex,
    //           opacity: 1,
    //         });
    //         this.columnsHeight[minColumnIndex] += this.gap + imgRect.height;
    //       }
    //     },
    //   },
    //   created() {
    //     const data = this.fetchData();
    //     this.imgList = data;
    //   },
    //   mounted() {
    //     // 计算列数
    //     const wrapper = this.$refs.wrapperRef;
    //     const wrapperClientWidth = wrapper.clientWidth;
    //     this.columns = Math.floor(wrapperClientWidth / (this.width + this.gap));
    //     this.columnsHeight = new Array(this.columns).fill(0);
    //   },
    // });
  </script>
  <script>
    // class _Promise {
    //   constructor(callback) {
    //     try {
    //       callback(this._resolve.bind(this), this._reject.bind(this));
    //     } catch (error) {
    //       this.exception = error;
    //       this._reject(error);
    //     }

    //     // 等待主线程收集完所有的 then/catch 回调之后，再决定是否直接抛出异常
    //     setTimeout(() => {
    //       if (this.exception !== undefined && !this.rejectList.length) {
    //         // 如果没有定义 catch 回调，那么直接抛出异常
    //         throw new Error(`Uncaught in promise: ${this.exception}`);
    //       }
    //     }, 0);
    //   }

    //   static resolve(value) {
    //     return new this((resolve) => {
    //       resolve(value);
    //     });
    //   }

    //   static reject(error) {
    //     return new this((resolve, reject) => {
    //       reject(error);
    //     });
    //   }

    //   static all(promiseList) {
    //     // 返回值的顺序和传入的 Promise 顺序相同；但是只要有一个 Promise rejected，那么就返回这个错误信息
    //     const result = [];
    //     let isExit = false;
    //     let count = 0;

    //     return new this((resolve, reject) => {
    //       for (let i = 0; i < promiseList.length; i++) {
    //         const v = promiseList[i];

    //         // 只要有一个 promise 为 rejected，那么直接终止循环
    //         if (isExit) {
    //           break;
    //         }
    //         // 如果是基本值
    //         if (!(v instanceof this)) {
    //           result[i] = v;
    //           count += 1;
    //         } else {
    //           // 如果是 Promise 实例
    //           v.then((res) => {
    //             // 多个 Promise 是依次执行的，无需等待，但是返回值的顺序还是按照传入的顺序
    //             result[i] = res;
    //             count += 1;

    //             if (count === promiseList.length) {
    //               resolve(result);
    //             }
    //           }).catch((err) => {
    //             isExit = true;
    //             reject(err);
    //           });
    //         }
    //       }
    //     });
    //   }

    //   static race(promiseList) {
    //     // 返回最早的 Promise 的结果，无论成功还是失败
    //     let isExit = false;

    //     return new this((resolve, reject) => {
    //       for (let i = 0; i < promiseList.length; i++) {
    //         const v = promiseList[i];
    //         // 只要某一个 promise 有了结果，则终止循环
    //         if (isExit) {
    //           break;
    //         }
    //         // 如果是基本值
    //         if (!(v instanceof this)) {
    //           isExit = true;
    //           resolve(v);
    //           break;
    //         } else {
    //           // 如果是 Promise 实例
    //           v.then((res) => {
    //             isExit = true;
    //             resolve(res);
    //           }).catch((err) => {
    //             isExit = true;
    //             reject(err);
    //           });
    //         }
    //       }
    //     });
    //   }

    //   status = "pending";
    //   value = undefined;
    //   // 存储异常信息，便于直接抛出异常（Uncaught in promise xxx）
    //   exception = undefined;
    //   // 存储 then/reject 回调，解决非链式调用的情况（p.then1; p.then2）
    //   resolveList = [];
    //   rejectList = [];

    //   _resolve(value) {
    //     // 浏览器无法模拟微任务，所以使用Promise代替，目的是为了在 then 方法成功注册回调之后再执行
    //     Promise.resolve().then(() => {
    //       if (this.status === "pending") {
    //         this.value = value;
    //         this.status = "fulfilled";

    //         // 如果当前 Promise 上注册的 onFulfilled/then 回调为空，那么值需要往下传递
    //         if (!this.resolveList.length) {
    //           if (this.rejectList.length) {
    //             this.rejectList.forEach((v) => {
    //               v.nextResolve(this.value);
    //             });
    //           }
    //         } else {
    //           // 如果当前 Promise 上已经注册了 onFulfilled/then 回调
    //           this.resolveList.forEach((v) => {
    //             let res;
    //             try {
    //               res = v.onFulfilled(this.value);
    //               v.nextResolve(res);
    //             } catch (e) {
    //               // 如果在执行 .then 回调的时候捕获到错误
    //               v.nextReject(e);
    //             }
    //           });
    //         }
    //       }
    //     });
    //   }

    //   _reject(error) {
    //     Promise.resolve().then(() => {
    //       if (this.status === "pending") {
    //         this.value = error;
    //         this.status = "rejected";
    //         this.exception = error;

    //         // 如果当前 Promise 上注册的 onRejected/catch 回调为空，那么待抛出的错误信息需要往下传递
    //         if (!this.rejectList.length) {
    //           if (this.resolveList.length) {
    //             this.resolveList.forEach((v) => {
    //               v.nextReject(this.exception);
    //             });
    //             // 重置当前的错误信息，因为错误已经传递给 then 回调里面的 Promise 了，所以当前 Promise 无需再抛出错误
    //             this.exception = undefined;
    //           }
    //         } else {
    //           // 如果当前 Promise 上已经注册了 onRejected/catch 回调
    //           this.rejectList.forEach((v) => {
    //             let res;
    //             try {
    //               let res = v.onRejected(this.value);
    //               v.nextResolve(res);
    //             } catch (e) {
    //               // 如果在执行 onRejected/catch 回调的时候捕获到错误
    //               v.nextReject(e);
    //             }
    //           });
    //         }
    //       }
    //     });
    //   }

    //   then(onFulfilled, onRejected) {
    //     // 链式调用（p.then.then）
    //     let p = new _Promise((nextResolve, nextReject) => {
    //       // 执行 then 方法的时候，如果此时 promise 还没有返回值
    //       // 那么分别将回调加入到队列中，等待 resolve/reject 时执行
    //       if (this.status === "pending") {
    //         if (onFulfilled) {
    //           this.resolveList.push({
    //             onFulfilled,
    //             nextResolve,
    //             nextReject,
    //           });
    //         }
    //         if (onRejected) {
    //           this.exception = undefined;
    //           this.rejectList.push({
    //             onRejected,
    //             nextResolve,
    //             nextReject,
    //           });
    //         }
    //       } else if (this.status === "fulfilled") {
    //         // 如果 promise 已经有返回值，直接调用回调
    //         if (onFulfilled) {
    //           let res = onFulfilled(this.value);
    //           nextResolve(res);
    //         }
    //       } else if (this.status === "rejected") {
    //         // 如果 promise 已经有返回值，直接调用回调
    //         if (onRejected) {
    //           let res = onRejected(this.value);
    //           nextResolve(res);
    //         }
    //       }
    //     });

    //     return p;
    //   }

    //   catch(onRejected) {
    //     return this.then(null, onRejected);
    //   }
    // }

    // let promise1 = new _Promise((resolve) => {
    //   setTimeout(() => {
    //     resolve(1);
    //   }, 1000);
    // });
    // let promise2 = new _Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve(2);
    //   }, 500);
    // });
    // let promise3 = new _Promise((resolve, reject) => {
    //   resolve(3);
    // });
    // let promise4 = 4;

    // _Promise.race([promise1, promise2, promise3]).then(
    //   (res) => {
    //     console.log("res :>> ", res);
    //   },
    //   (err) => {
    //     console.log("err :>> ", err);
    //   }
    // );
  </script>
  <script>
    class Router {
      static createHashRouter(options) {
        function getPath() {
          return location.hash.replace(/^#/, "");
        }
        const path = getPath();
        // 历史记录栈
        const stack = [];

        if (path) {
          stack.push(path);
        }

        return {
          stack,
          // 当前路径对应栈中的下标
          currentIndex: 0,
          prevIndex: 0,
          beforeEach: null,
          push(ops, cb, isGo) {
            // 执行 beforeEach 钩子
            if (this.beforeEach) {
              this.beforeEach(ops.path, currentPath, (newOps) => {
                ops = newOps || ops;
                location.hash = `${ops.path}`;
                // 如果是通过 router.go() 跳转的，则不添加历史记录到栈
                if (!isGo) {
                  this.stack.push(ops.path);
                  this.prevIndex = this.currentIndex;
                  this.currentIndex = this.stack.length - 1;
                }
                cb &&
                  cb(this.stack[this.currentIndex], this.stack[this.prevIndex]);
              });
            } else {
              location.hash = `${ops.path}`;
              // 如果是通过 router.go() 跳转的，则不添加历史记录到栈
              if (!isGo) {
                this.stack.push(ops.path);
                this.prevIndex = this.currentIndex;
                this.currentIndex = this.stack.length - 1;
              }
              cb &&
                cb(this.stack[this.currentIndex], this.stack[this.prevIndex]);
            }
          },
          register(cb) {
            window.addEventListener("hashchange", cb);
          },
          getPath,
          go(num, cb) {
            let stackLength = this.stack.length;

            if (!stackLength || num === 0) {
              return;
            }

            // 边界处理
            let i = this.currentIndex;
            let count = 0;
            if (num > 0) {
              while (i <= stackLength - 1 && count <= num - 1) {
                i++;
                count++;
              }
            } else if (num < 0) {
              num = Math.abs(num);
              while (i >= 0 && count <= num - 1) {
                i--;
                count++;
              }
            }

            // 不能超出历史记录
            i = Math.min(stackLength - 1, i);
            i = Math.max(0, i);

            this.push(
              {
                path: this.stack[i],
              },
              cb,
              true
            );
            this.prevIndex = this.currentIndex;
            this.currentIndex = i;
          },
          replace(ops, cb) {
            // 执行 beforeEach 钩子
            if (this.beforeEach) {
              this.beforeEach(ops.path, currentPath, (newOps) => {
                ops = newOps || ops;
                // 直接替换当前的路径
                this.stack[this.currentIndex] = ops.path;
                location.hash = `${ops.path}`;
                cb &&
                  cb(this.stack[this.currentIndex], this.stack[this.prevIndex]);
              });
            } else {
              // 直接替换当前的路径
              this.stack[this.currentIndex] = ops.path;
              location.hash = `${ops.path}`;
              cb &&
                cb(this.stack[this.currentIndex], this.stack[this.prevIndex]);
            }
          },
        };
      }

      static createHistoryRouter(options) {
        const event = new Event("changehistory");
        const { pushState, replaceState } = window.history;
        window.history.pushState = function (state, title, url) {
          pushState.call(this, state, title, url);
          window.dispatchEvent(event);
        };
        window.history.replaceState = function (state, title, url) {
          replaceState.call(this, state, title, url);
          window.dispatchEvent(event);
        };

        return {
          beforeEach: null,
          getPath() {
            return location.pathname;
          },
          register(cb) {
            window.addEventListener("popstate", cb);
            window.addEventListener("changehistory", cb);
          },
          push(ops, cb) {
            window.history.pushState(null, null, ops.path);
            cb && cb(ops.path);
          },
          go(num, cb) {
            window.history.go(num);
            cb && cb(this.getPath());
          },
          replace(ops, cb) {
            window.history.replaceState(null, null, ops.path);
            cb && cb(ops.path);
          },
        };
      }

      constructor(options) {
        for (const key in options) {
          if (this.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }

        switch (this.mode) {
          case "hash": {
            this.router = Router.createHashRouter({});
            this.router.register(this.notify.bind(this));
            break;
          }
          case "history": {
            this.router = Router.createHistoryRouter({});
            this.router.register(this.notify.bind(this));
            break;
          }
          default: {
            break;
          }
        }
        this.routes = this._initRoutes(this.routes);
        const currentPath = this.router.getPath();
        this.prevRoute = this.currentRoute;
        this.currentRoute = this._findRouteByPath(currentPath);
      }

      baseURL = "";
      mode = "hash";
      routes = [];
      // 上一个路由
      prevRoute = null;
      // 当前路由
      currentRoute = null;
      router = null;
      deps = [];

      _initRoutes(routes) {
        function helper(children, parentRoute) {
          for (let i = 0; i < children.length; i++) {
            children[i] = new Route(children[i]);
            let v = children[i];

            // 如果子路由的 path 不以 / 开头
            if (!/^\//.test(v.path) && parentRoute) {
              v.path = `${parentRoute.path}/${v.path}`;
            }

            if (v.children && v.children.length) {
              helper(v.children, children[i]);
            }
          }
        }

        helper(routes, routes);
        return routes;
      }

      _findRouteByPath(path) {
        // 测试用
        path = path.replace(this.baseURL, "");

        function helper(routes) {
          for (let i = 0; i < routes.length; i++) {
            const v = routes[i];
            if (v.path === path) {
              return v;
            }
            if (v.children && v.children.length) {
              helper(v.children);
            }
          }
        }

        return helper(this.routes);
      }

      /**
       * 注册回调，当路由发生变化时触发
       **/
      depend(cb) {
        this.deps.push(cb);
      }

      /**
       * 当路由变化时执行回调
       **/
      notify() {
        this.deps.forEach((v) => v(this.currentRoute, this.prevRoute));
      }

      getRoutes() {
        return this.routes;
      }

      push(ops) {
        const nextRoute = this._findRouteByPath(ops.path);
        if (nextRoute === this.currentRoute) {
          return;
        }

        this.router.push(ops, (path) => {
          this.prevRoute = this.currentRoute;
          this.currentRoute = this._findRouteByPath(path) || null;
        });
      }

      go(num) {
        this.router.go(num, (newPath, oldPath) => {
          this.prevRoute = this.currentRoute;
          this.currentRoute = this._findRouteByPath(newPath) || null;
        });
      }

      back() {
        this.go(-1);
      }

      forward() {
        this.go(1);
      }

      replace(ops) {
        const nextRoute = this._findRouteByPath(ops.path);
        if (nextRoute === this.currentRoute) {
          return;
        }

        this.router.replace(ops, (newPath, oldPath) => {
          this.prevRoute = this.currentRoute;
          this.currentRoute = this._findRouteByPath(newPath) || null;
        });
      }

      beforeEach(cb) {
        this.router.beforeEach = (toPath, fromPath, next) => {
          // 寻找 Route
          const to = this._findRouteByPath(toPath);
          const from = this._findRouteByPath(fromPath);
          cb(to, from, next);
        };
      }
    }
    class Route {
      constructor(options) {
        for (const key in options) {
          if (this.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }

      path = "";
      children = [];
      name = "";
      beforeEnter = () => {};
      meta = {};
    }

    const router = new Router({
      mode: "history",
      baseURL: "http://localhost:5500/examples/demo/index.html",
      routes: [
        {
          path: "/home",
          component() {
            return `home page`;
          },
        },
        {
          path: "/about",
          component() {
            return `about page`;
          },
        },
        {
          path: "/category",
          component() {
            return `category page`;
          },
          children: [
            {
              path: "game",
              component() {
                return `category-game page`;
              },
            },
            {
              path: "sport",
              component() {
                return `category-sport page`;
              },
            },
          ],
        },
      ],
    });
    router.depend((currentRoute, prevRoute) => {
      console.log("currentRoute, prevRoute :>> ", currentRoute, prevRoute);
    });
    router.beforeEach((to, from, next) => {
      if (to.path === "/home") {
        next({
          path: "/about",
        });
      } else {
        next();
      }
    });

    const routerItems = document.querySelectorAll(".router-item");
    routerItems.forEach((v) =>
      v.addEventListener("click", handleLinkClick, false)
    );

    function handleLinkClick(e) {
      if (e) {
        const target = e.target;
        const baseURL = "http://localhost:5500/examples/demo/index.html";
        const path = target.dataset.path;
        router.push({
          path: `${baseURL}${path}`,
        });
      }
    }
  </script>
  <script>
    // class Store {
    //   constructor(options) {
    //     this.options = {
    //       ...this.options,
    //       ...options,
    //     };
    //     this._initModuleMap(this.options);
    //   }

    //   options = {
    //     namespaced: false,
    //     modules: {},
    //     state: {},
    //     getters: {},
    //     mutations: {},
    //     actions: {},
    //   };
    //   _modulePathMap = {};
    //   _mutationMap = {};
    //   _actionMap = {};
    //   _getterMap = {};

    //   _initModuleMap(options) {
    //     const newModulePathMap = {};
    //     const newMutationMap = {};
    //     const newActionMap = {};
    //     const newGetterMap = {};

    //     function helper(modules, parentPath) {
    //       for (const key in modules) {
    //         if (Object.hasOwnProperty.call(modules, key)) {
    //           const value = modules[key];
    //           let currentPath = !parentPath ? `${key}` : `${parentPath}/${key}`;

    //           if (!value.namespaced) {
    //             if (value.mutations) {
    //               for (const mutationKey in value.mutations) {
    //                 const mutationFunc = value.mutations[mutationKey];
    //                 newMutationMap[mutationKey] = mutationFunc.bind(
    //                   value,
    //                   value.state
    //                 );
    //               }
    //             }
    //             if (value.actions) {
    //               for (const actionKey in value.actions) {
    //                 const actionFunc = value.actions[actionKey];
    //                 newActionMap[actionKey] = actionFunc.bind(
    //                   value,
    //                   value.state
    //                 );
    //               }
    //             }
    //             if (value.getters) {
    //               for (const getterKey in value.getters) {
    //                 const getterFunc = value.getters[getterKey];
    //                 newGetterMap[getterKey] = getterFunc.bind(
    //                   value,
    //                   value.state
    //                 );
    //               }
    //             }
    //           }
    //           newModulePathMap[currentPath] = value;
    //           if (value.modules) {
    //             helper(value.modules, currentPath);
    //           }
    //         }
    //       }
    //     }
    //     helper(options.modules, ``);

    //     this._modulePathMap = newModulePathMap;
    //     this._mutationMap = newMutationMap;
    //     this._actionMap = newActionMap;
    //     this._getterMap = newGetterMap;
    //   }

    //   commit(type, payload) {
    //     if (this._mutationMap.hasOwnProperty(type)) {
    //       this._mutationMap[type](payload);
    //     } else {
    //       let split = type.split("/");
    //       let path = split.slice(0, split.length - 1).join("/");
    //       let mutationName = split[split.length - 1];
    //       const module = this._modulePathMap[path];

    //       module["mutations"][mutationName](module.state, payload);
    //     }
    //   }

    //   dispatch(type, payload) {
    //     if (this._actionMap.hasOwnProperty(type)) {
    //       this._actionMap[type](payload);
    //     } else {
    //       let split = type.split("/");
    //       let path = split.slice(0, split.length - 1).join("/");
    //       let actionName = split[split.length - 1];
    //       const module = this._modulePathMap[path];

    //       module["actions"][actionName](module, payload);
    //     }
    //   }
    // }

    // const moduleAA = {
    //   namespaced: true,
    //   state: {
    //     e: 5,
    //   },
    //   mutations: {
    //     SET_e(state, payload) {
    //       state.e = payload;
    //     },
    //   },
    // };
    // const moduleA = {
    //   namespaced: true,
    //   state: {
    //     c: 3,
    //     d: 4,
    //   },
    //   modules: {
    //     moduleAA,
    //   },
    //   mutations: {
    //     SET_c(state, payload) {
    //       state.c = payload;
    //     },
    //     SET_d(state, payload) {
    //       state.d = payload;
    //     },
    //   },
    //   getters: {
    //     GET_c(state) {
    //       return state.c + "-" + state.c;
    //     },
    //   },
    // };
    // const moduleB = {
    //   state: {
    //     f: 6,
    //   },
    //   mutations: {
    //     SET_f(state, payload) {
    //       state.f = payload;
    //     },
    //   },
    //   actions: {
    //     DISPATCH_GET_f(store) {
    //       setTimeout(() => {
    //         store.commit("SET_f", state.f * state.f);
    //       }, 1000);
    //     },
    //   },
    //   getters: {
    //     GET_f(state) {
    //       return state.f;
    //     },
    //   },
    // };
    // const store = new Store({
    //   state: {
    //     a: 1,
    //     b: 2,
    //   },
    //   modules: {
    //     moduleA,
    //     moduleB,
    //   },
    //   mutations: {
    //     SET_a(state, payload) {
    //       state.a = payload;
    //     },
    //     SET_b(state, payload) {
    //       state.b = payload;
    //     },
    //   },
    //   getters: {
    //     GET_a(state) {
    //       return state.a + "-" + state.a;
    //     },
    //   },
    // });

    // console.log("store :>> ", store);
    // store.commit("moduleA/moduleAA/SET_e", 1);
    // store.commit("SET_f", 1);
  </script>

  <script>
    // function getType(v) {
    //   const t = {}.toString.call(v);
    //   return t.substring(8, t.length - 1).toLowerCase();
    // }
    // function genWrapper(type) {
    //   const t = {
    //     map: new Map(),
    //     set: new Set(),
    //     array: [],
    //     object: {},
    //   };

    //   return t[type];
    // }
    // function canCopyDirectly(type) {
    //   return [
    //     "string",
    //     "boolean",
    //     "number",
    //     "undefined",
    //     "null",
    //     "symbol",
    //     "function",
    //   ].includes(type);
    // }
    // function _deepCloneHelper(target, wrapper, targetType) {
    //   if (["map", "set"].includes(targetType)) {
    //     for (const [key, value] of target.entries()) {
    //       if (canCopyDirectly(getType(value))) {
    //         if (targetType === "map") {
    //           wrapper.set(key, value);
    //         } else {
    //           wrapper.add(value);
    //         }
    //       } else {
    //         const g = genWrapper(getType(value));
    //         if (targetType === "map") {
    //           wrapper.set(key, g);
    //           _deepCloneHelper(value, g, getType(value));
    //         } else {
    //           wrapper.add(g);
    //           _deepCloneHelper(value, g, getType(value));
    //         }
    //       }
    //     }
    //   } else {
    //     for (const key in target) {
    //       if (Object.hasOwnProperty.call(target, key)) {
    //         const value = target[key];
    //         if (canCopyDirectly(getType(value))) {
    //           wrapper[key] = value;
    //         } else {
    //           wrapper[key] = genWrapper(getType(value));
    //           _deepCloneHelper(value, wrapper[key], getType(value));
    //         }
    //       }
    //     }
    //   }
    // }
    // function deepClone(target) {
    //   const targetType = getType(target);
    //   const wrapper = genWrapper(targetType);

    //   _deepCloneHelper(target, wrapper, targetType);

    //   return wrapper;
    // }

    // const target1 = [
    //   1,
    //   false,
    //   function a() {
    //     console.log(b);
    //   },
    //   null,
    //   undefined,
    //   {
    //     a: 1,
    //     b: [1, 2, 3, false],
    //     c: {
    //       d: [5, 6, 7],
    //     },
    //     e: [
    //       {
    //         f: [9, 10, 11],
    //       },
    //     ],
    //     g: undefined,
    //   },
    //   [12, 13, { h: 14 }],
    //   new Map([
    //     [0, { a: 1 }],
    //     [1, { b: [2] }],
    //   ]),
    //   new Set([
    //     { a: 1, b: 2 },
    //     { c: 3, d: 4 },
    //   ]),
    // ];
    // const clonedTarget1 = deepClone(target1);
    // clonedTarget1[5].c.d.push(8);
    // console.log("clonedTarget1 :>> ", clonedTarget1);
    // console.log("target1 :>> ", target1);
    // console.log("clonedTarget1[2] :>> ", clonedTarget1[5] === target1[5]);
    // console.log("clonedTarget1[2] :>> ", clonedTarget1[7] === target1[7]);
    // clonedTarget1[7].set(0, 2);
    // clonedTarget1[8].add(1);
    // console.log("clonedTarget1 :>> ", clonedTarget1);
    // console.log("target1 :>> ", target1);
  </script>
  <script>
    const chain = [];
    const config = {
      headers: {},
      method: "get",
      url: "https://www.yyge.top",
    };

    function request(config) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          const response = {
            status: 200,
            data: {},
          };
          const error = {
            error: new Error("123"),
            response,
          };
          // resolve(response);
          reject(error);
        }, 1000);
      });
    }
    function interceptorReqSuccess(config) {
      config.headers.token = "xxxxxx";
      return config;
    }
    function interceptorReqFail(error) {
      error.config.reason = "errorerror";
      return error;
    }
    function interceptorResSuccess(response) {
      response.data.a = 1;
      return response;
    }
    function interceptorResFail(error) {
      error.response.data.reason = "errorerror";
      return error;
    }

    chain.unshift(interceptorReqSuccess, interceptorReqFail);
    chain.push(request, undefined, interceptorResSuccess, interceptorResFail);

    let promise = Promise.resolve(config);

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    promise
      .then((response) => {
        console.log("response :>> ", response);
      })
      .catch((error) => {
        console.log("error :>> ", error);
      });
  </script>
</html>
