<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>demo</title>
    <!-- Delete ".min" for console warnings in development -->
    <script src="../../dist/vue.js"></script>
    <style>
      html,
      body {
        height: 100%;
      }
      body,
      ul,
      li,
      p {
        margin: 0;
        padding: 0;
        list-style: none;
      }
      #wrapper {
        position: relative;
        width: 800px;
        margin: 0 auto;
      }
      img {
        position: absolute;
        transition: opacity 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <template id="appComponent">
      <div v-if="flag"></div>
    </template>

    <div id="router-demo">
      <div>
        <a class="router-item" data-path="/home">/home</a>
        <a class="router-item" data-path="/about">/about</a>
        <a class="router-item" data-path="/category">/category</a>
      </div>
      <button onclick="router.go(-1)">go</button>
      <button onclick="router.forward()">forward</button>
      <button onclick="router.back()">back</button>
    </div>
  </body>
  <script>
    const AppComponent = Vue.component("AppComponent", {
      template: "#appComponent",
      props: {
        flag: {
          type: Boolean,
          required: true,
        },
      },
    });
    const AppComponent2 = Vue.component("AppComponent2", {
      render(h) {
        return h(
          "div",
          {
            class: "app-2-container",
          },
          "5678"
        );
      },
    });
    const app = new Vue({
      el: "#app",
      template: `
        <div class="container">
          <app-component :flag="flag"></app-component>
          <button @click="flag = !flag">Toggle flag</button>
        </div>
      `,
      components: {
        AppComponent,
      },
      data() {
        return {
          firstName: "zhaoyang",
          lastName: "duan",
          flag: false,
        };
      },
      computed: {
        computedFlag() {
          return this.flag ? 1 : 0;
        },
        computedName() {
          return `${this.lastName} ${this.firstName}`;
        },
      },
    });
  </script>
  <script>
    // const vm = new Vue({
    //   el: ".wrapper",
    //   data() {
    //     return {
    //       data: this.getData(),
    //       screenHeight: window.innerHeight,
    //       positions: [],
    //       scrollTop: 0,

    //       initialItemHeight: 100,
    //     };
    //   },
    //   computed: {
    //     computedWrapper() {
    //       return this.$refs.wrapperRef;
    //     },
    //     computedList() {
    //       return this.$refs.listRef;
    //     },
    //     computedGhost() {
    //       return this.$refs.ghostRef;
    //     },
    //     computedItems() {
    //       return this.computedList ? this.computedList.children : [];
    //     },
    //     computedItemContents() {
    //       return this.computedList.querySelectorAll("p");
    //     },
    //     computedGhostHeight() {
    //       return this.positions[this.positions.length - 1].bottom;
    //     },
    //     computedStartIndex() {
    //       if (this.scrollTop === 0) {
    //         return 0;
    //       }
    //       const foundStart = this.positions.find(
    //         (v) => this.scrollTop >= v.bottom
    //       );
    //       return foundStart ? foundStart.index : 0;
    //     },
    //     computedEndIndex() {
    //       const foundEnd = this.positions.find(
    //         (v) =>
    //           v.bottom - this.positions[this.computedStartIndex].bottom >=
    //           this.screenHeight
    //       );

    //       return foundEnd ? foundEnd.index : 0;
    //     },
    //     computedFinalData() {
    //       return this.data.slice(
    //         this.computedStartIndex,
    //         this.computedEndIndex + 1
    //       );
    //     },
    //   },
    //   watch: {
    //     computedStartIndex(newStartIndex) {
    //       console.log("newStartIndex :>> ", newStartIndex);
    //     },
    //     computedEndIndex(newEndIndex) {
    //       console.log("newEndIndex :>> ", newEndIndex);
    //     },
    //   },
    //   methods: {
    //     getData() {
    //       const data = [];

    //       for (let i = 0; i < 1000; i++) {
    //         data.push({
    //           _id: i,
    //           value: `${i}-${String(i).repeat(
    //             Math.random() * (1000 - 800) + 50
    //           )}`,
    //         });
    //       }
    //       return data;
    //     },
    //     updatePositions() {
    //       [...this.computedItems].forEach((v) => {
    //       const index = Number(v.getAttribute("id"));
    //       const rect = v.getBoundingClientRect();
    //       const prevIndex = index - 1 < 0 ? 0 : index - 1;

    //       console.log('prevIndex :>> ', prevIndex);

    //       this.positions[index] = {
    //         ...this.positions[index],
    //         height: rect.height,
    //         // 上一个列表项的 bottom + 当前列表项的高度
    //         bottom: rect.bottom + this.positions[prevIndex].bottom,
    //         top: this.positions[prevIndex].bottom,
    //       };
    //     });
    //     },
    //   },
    //   created() {
    //     this.positions = this.data.map((v, index) => ({
    //       index,
    //       height: this.initialItemHeight,
    //       bottom: (index + 1) * this.initialItemHeight,
    //       top: index * this.initialItemHeight,
    //     }));
    //   },
    //   mounted() {
    //     this.computedWrapper.addEventListener("scroll", (e) => {
    //       this.scrollTop = e.currentTarget.scrollTop;
    //     });
    //     this.updatePositions();
    //   },
    //   updated() {
    //     this.updatePositions();
    //   },
    // });
  </script>
  <script>
    // const list = document.getElementById("list");
    // const wrapper = document.querySelector(".wrapper");
    // const ghost = document.querySelector("#ghost");
    // const content = document.querySelector(".item-content");

    // const data = getData();
    // // 每一项的预估高度
    // const itemHeight = 100;
    // // 可视区域的高度
    // const screenHeight = window.innerHeight;
    // // 每次渲染多少个
    // const groupSize = Math.ceil(screenHeight / itemHeight);
    // // 起始位置
    // let startIndex = 0;
    // // 最终位置
    // let endIndex =
    //   startIndex + groupSize <= data.length
    //     ? startIndex + groupSize - 1
    //     : data.length - 1;
    // // 存储列表每一项的真实高度
    // const positions = data.map((v, index) => {
    //   return {
    //     index,
    //     height: itemHeight,
    //     top: index * itemHeight,
    //     bottom: (index + 1) * itemHeight,
    //   };
    // });

    // function getData() {
    //   const data = [];

    //   for (let i = 0; i < 1000; i++) {
    //     data.push({
    //       _id: i,
    //       value: `${i}-${String(i).repeat(Math.random() * (1000 - 800) + 50)}`,
    //     });
    //   }
    //   return data;
    // }
    // function throttle(callback, timestamp) {
    //   let prevTime = Date.now();
    //   return function (...args) {
    //     let currentTime = Date.now();
    //     if (currentTime - prevTime >= timestamp) {
    //       callback.apply(this, args);
    //       prevTime = currentTime;
    //     }
    //   };
    // }
    // function render(start, end) {
    //   if (positions.length !== data.length) {
    //     // 把已经渲染出来的列表项的位置大小信息缓存起来
    //     const children = list.querySelectorAll(".item-content");
    //     for (let i = 0; i < children.length; i++) {
    //       const dom = children[i];
    //       const rect = dom.getBoundingClientRect();
    //       const pos = Number(dom.getAttribute("id"));
    //       positions[pos] = {
    //         ...positions[pos],
    //         height: rect.height,
    //         top: rect.top,
    //         bottom: rect.bottom,
    //       };
    //     }
    //   }

    //   const div = document.createElement("div");
    //   for (let i = start; i <= end; i++) {
    //     const li = document.createElement("li");
    //     const p = document.createElement("p");
    //     li.appendChild(p);
    //     li.setAttribute("id", data[i]._id);
    //     li.classList.add("item");
    //     p.classList.add("item-content");
    //     p.textContent = data[i].value;
    //     li.style.cssText += `height: ${positions[i] ? "auto" : itemHeight}px`;
    //     div.appendChild(li);
    //   }
    //   list.innerHTML = div.innerHTML;
    // }

    // // 第一次渲染
    // render(startIndex, endIndex);
    // // 监听滚动，滚动时动态计算起始和结束位置
    // wrapper.addEventListener("scroll", throttle(handleScroll, 10));

    // function handleScroll(e) {
    //   const scrollTop = this.scrollTop;
    //   // startIndex = Math.ceil(scrollTop / itemHeight);
    //   // endIndex =
    //   //   startIndex + groupSize <= data.length
    //   //     ? startIndex + groupSize - 1
    //   //     : data.length - 1;

    //   let newStartIndex = positions.find((v) => v.top <= 0);
    //   let newEndIndex = positions.find((v) => v.bottom <= 0);
    //   startIndex = newStartIndex ? newStartIndex.index + 1 : 0;
    //   endIndex = newEndIndex ? newEndIndex.index + 1 : 10;

    //   render(startIndex, endIndex);

    //   // 重新计算渲染区域的位置，避免被顶到上面去
    //   list.style.cssText += `
    //     transform: translate3d(0, ${scrollTop}px, 0)
    //   `;
    // }
  </script>
  <script>
    // 懒加载
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: this.fetchData(),
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const result = [];

    //       for (let i = 0; i < 50; i++) {
    //         result.push({
    //           _id: i,
    //           src: `http://iph.href.lu/100x100?text=${i}`,
    //           dataSrc:
    //             "https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg",
    //           width: 100,
    //           height: 100,
    //         });
    //       }

    //       return result;
    //     },
    //   },
    //   mounted() {
    //     const imgs = this.$refs.imgRef;
    //     const io = new IntersectionObserver(
    //       (entries) => {
    //         entries.forEach((entry) => {
    //           if (entry.isIntersecting) {
    //             entry.target.setAttribute(
    //               "src",
    //               entry.target.getAttribute("data-src")
    //             );
    //           }
    //         });
    //       },
    //       {
    //         threshold: 0.5,
    //       }
    //     );

    //     imgs.forEach((v) => {
    //       io.observe(v);
    //     });
    //   },
    // });
  </script>
  <script>
    // 瀑布流
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: [],
    //       width: 150, // 固定宽度
    //       gap: 10, // 间隔
    //       columns: 1, // 列数
    //       columnsHeight: [], // 存储每一列的高度
    //       loadedImgCount: 0, // 记录当前已经加载完成的图片数量
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const data = [];

    //       for (let i = 0; i < 50; i++) {
    //         const height = Math.floor(Math.random() * (400 - 100) + 100);
    //         data.push({
    //           _id: i,
    //           src: `http://iph.href.lu/${this.width}x${height}?text=${i}`,
    //           width: this.width,
    //           height: 0,
    //           left: 0,
    //           top: 0,
    //           opacity: 0,
    //         });
    //       }

    //       return data;
    //     },
    //     imageLoaded(e) {
    //       this.loadedImgCount += 1;

    //       const img = e.target;
    //       const imgRect = img.getBoundingClientRect();
    //       const imgIndex = +img.dataset.index;

    //       // 第一行
    //       if (this.loadedImgCount <= this.columns) {
    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap,
    //           left: (this.width + this.gap) * (this.loadedImgCount - 1),
    //           opacity: 1,
    //         });
    //         this.columnsHeight[this.loadedImgCount - 1] =
    //           this.gap + imgRect.height;
    //       } else {
    //         // 其余行
    //         // 寻找最短的一列插入
    //         const minColumnHeight = Math.min(...this.columnsHeight);
    //         const minColumnIndex = this.columnsHeight.findIndex(
    //           (v) => v === minColumnHeight
    //         );

    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap + minColumnHeight,
    //           left: (this.width + this.gap) * minColumnIndex,
    //           opacity: 1,
    //         });
    //         this.columnsHeight[minColumnIndex] += this.gap + imgRect.height;
    //       }
    //     },
    //   },
    //   created() {
    //     const data = this.fetchData();
    //     this.imgList = data;
    //   },
    //   mounted() {
    //     // 计算列数
    //     const wrapper = this.$refs.wrapperRef;
    //     const wrapperClientWidth = wrapper.clientWidth;
    //     this.columns = Math.floor(wrapperClientWidth / (this.width + this.gap));
    //     this.columnsHeight = new Array(this.columns).fill(0);
    //   },
    // });
  </script>
  <script>
    // class _Promise {
    //   constructor(callback) {
    //     try {
    //       callback(this._resolve.bind(this), this._reject.bind(this));
    //     } catch (error) {
    //       this.exception = error;
    //       this._reject(error);
    //     }

    //     // 等待主线程收集完所有的 then/catch 回调之后，再决定是否直接抛出异常
    //     setTimeout(() => {
    //       if (this.exception !== undefined && !this.rejectList.length) {
    //         // 如果没有定义 catch 回调，那么直接抛出异常
    //         throw new Error(`Uncaught in promise: ${this.exception}`);
    //       }
    //     }, 0);
    //   }

    //   static resolve(value) {
    //     return new this((resolve) => {
    //       resolve(value);
    //     });
    //   }

    //   static reject(error) {
    //     return new this((resolve, reject) => {
    //       reject(error);
    //     });
    //   }

    //   static all(promiseList) {
    //     // 返回值的顺序和传入的 Promise 顺序相同；但是只要有一个 Promise rejected，那么就返回这个错误信息
    //     const result = [];
    //     let isExit = false;
    //     let count = 0;

    //     return new this((resolve, reject) => {
    //       for (let i = 0; i < promiseList.length; i++) {
    //         const v = promiseList[i];

    //         // 只要有一个 promise 为 rejected，那么直接终止循环
    //         if (isExit) {
    //           break;
    //         }
    //         // 如果是基本值
    //         if (!(v instanceof this)) {
    //           result[i] = v;
    //           count += 1;
    //         } else {
    //           // 如果是 Promise 实例
    //           v.then((res) => {
    //             // 多个 Promise 是依次执行的，无需等待，但是返回值的顺序还是按照传入的顺序
    //             result[i] = res;
    //             count += 1;

    //             if (count === promiseList.length) {
    //               resolve(result);
    //             }
    //           }).catch((err) => {
    //             isExit = true;
    //             reject(err);
    //           });
    //         }
    //       }
    //     });
    //   }

    //   static race(promiseList) {
    //     // 返回最早的 Promise 的结果，无论成功还是失败
    //     let isExit = false;

    //     return new this((resolve, reject) => {
    //       for (let i = 0; i < promiseList.length; i++) {
    //         const v = promiseList[i];
    //         // 只要某一个 promise 有了结果，则终止循环
    //         if (isExit) {
    //           break;
    //         }
    //         // 如果是基本值
    //         if (!(v instanceof this)) {
    //           isExit = true;
    //           resolve(v);
    //           break;
    //         } else {
    //           // 如果是 Promise 实例
    //           v.then((res) => {
    //             isExit = true;
    //             resolve(res);
    //           }).catch((err) => {
    //             isExit = true;
    //             reject(err);
    //           });
    //         }
    //       }
    //     });
    //   }

    //   status = "pending";
    //   value = undefined;
    //   // 存储异常信息，便于直接抛出异常（Uncaught in promise xxx）
    //   exception = undefined;
    //   // 存储 then/reject 回调，解决非链式调用的情况（p.then1; p.then2）
    //   resolveList = [];
    //   rejectList = [];

    //   _resolve(value) {
    //     // 浏览器无法模拟微任务，所以使用Promise代替，目的是为了在 then 方法成功注册回调之后再执行
    //     Promise.resolve().then(() => {
    //       if (this.status === "pending") {
    //         this.value = value;
    //         this.status = "fulfilled";

    //         // 如果当前 Promise 上注册的 onFulfilled/then 回调为空，那么值需要往下传递
    //         if (!this.resolveList.length) {
    //           if (this.rejectList.length) {
    //             this.rejectList.forEach((v) => {
    //               v.nextResolve(this.value);
    //             });
    //           }
    //         } else {
    //           // 如果当前 Promise 上已经注册了 onFulfilled/then 回调
    //           this.resolveList.forEach((v) => {
    //             let res;
    //             try {
    //               res = v.onFulfilled(this.value);
    //               v.nextResolve(res);
    //             } catch (e) {
    //               // 如果在执行 .then 回调的时候捕获到错误
    //               v.nextReject(e);
    //             }
    //           });
    //         }
    //       }
    //     });
    //   }

    //   _reject(error) {
    //     Promise.resolve().then(() => {
    //       if (this.status === "pending") {
    //         this.value = error;
    //         this.status = "rejected";
    //         this.exception = error;

    //         // 如果当前 Promise 上注册的 onRejected/catch 回调为空，那么待抛出的错误信息需要往下传递
    //         if (!this.rejectList.length) {
    //           if (this.resolveList.length) {
    //             this.resolveList.forEach((v) => {
    //               v.nextReject(this.exception);
    //             });
    //             // 重置当前的错误信息，因为错误已经传递给 then 回调里面的 Promise 了，所以当前 Promise 无需再抛出错误
    //             this.exception = undefined;
    //           }
    //         } else {
    //           // 如果当前 Promise 上已经注册了 onRejected/catch 回调
    //           this.rejectList.forEach((v) => {
    //             let res;
    //             try {
    //               let res = v.onRejected(this.value);
    //               v.nextResolve(res);
    //             } catch (e) {
    //               // 如果在执行 onRejected/catch 回调的时候捕获到错误
    //               v.nextReject(e);
    //             }
    //           });
    //         }
    //       }
    //     });
    //   }

    //   then(onFulfilled, onRejected) {
    //     // 链式调用（p.then.then）
    //     let p = new _Promise((nextResolve, nextReject) => {
    //       // 执行 then 方法的时候，如果此时 promise 还没有返回值
    //       // 那么分别将回调加入到队列中，等待 resolve/reject 时执行
    //       if (this.status === "pending") {
    //         if (onFulfilled) {
    //           this.resolveList.push({
    //             onFulfilled,
    //             nextResolve,
    //             nextReject,
    //           });
    //         }
    //         if (onRejected) {
    //           this.exception = undefined;
    //           this.rejectList.push({
    //             onRejected,
    //             nextResolve,
    //             nextReject,
    //           });
    //         }
    //       } else if (this.status === "fulfilled") {
    //         // 如果 promise 已经有返回值，直接调用回调
    //         if (onFulfilled) {
    //           let res = onFulfilled(this.value);
    //           nextResolve(res);
    //         }
    //       } else if (this.status === "rejected") {
    //         // 如果 promise 已经有返回值，直接调用回调
    //         if (onRejected) {
    //           let res = onRejected(this.value);
    //           nextResolve(res);
    //         }
    //       }
    //     });

    //     return p;
    //   }

    //   catch(onRejected) {
    //     return this.then(null, onRejected);
    //   }
    // }

    // let promise1 = new _Promise((resolve) => {
    //   setTimeout(() => {
    //     resolve(1);
    //   }, 1000);
    // });
    // let promise2 = new _Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve(2);
    //   }, 500);
    // });
    // let promise3 = new _Promise((resolve, reject) => {
    //   resolve(3);
    // });
    // let promise4 = 4;

    // _Promise.race([promise1, promise2, promise3]).then(
    //   (res) => {
    //     console.log("res :>> ", res);
    //   },
    //   (err) => {
    //     console.log("err :>> ", err);
    //   }
    // );
  </script>
  <script>
    class Router {
      static createHashRouter(options) {
        function getPath() {
          return location.hash.replace(/^#/, "");
        }
        const path = getPath();
        // 历史记录栈
        const stack = [];

        if (path) {
          stack.push(path);
        }

        return {
          stack,
          // 当前路径对应栈中的下标
          currentIndex: 0,
          push(ops, cb, isGo) {
            // 路径相同则不入栈
            const currentPath = this.getPath();
            if (currentPath === ops.path) {
              return;
            }
            location.hash = `${ops.path}`;
            // 如果是通过 router.go() 跳转的，则不添加历史记录到栈
            if (!isGo) {
              this.stack.push(ops.path);
              this.currentIndex = this.stack.length - 1;
            }
            cb && cb(ops.path);
          },
          register(cb) {
            window.addEventListener("hashchange", cb);
          },
          getPath,
          go(num, cb) {
            let stackLength = this.stack.length;

            if (!stackLength || num === 0) {
              return;
            }

            // 边界处理
            let i = this.currentIndex;
            let count = 0;
            if (num > 0) {
              while (i <= stackLength - 1 && count <= num - 1) {
                i++;
                count++;
              }
            } else if (num < 0) {
              num = Math.abs(num);
              while (i >= 0 && count <= num - 1) {
                i--;
                count++;
              }
            }

            // 不能超出历史记录
            i = Math.min(stackLength - 1, i);
            i = Math.max(0, i);

            this.push(
              {
                path: this.stack[i],
              },
              cb,
              true
            );
            this.currentIndex = i;
          },
        };
      }

      constructor(options) {
        for (const key in options) {
          if (this.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }

        switch (this.mode) {
          case "hash": {
            this.router = Router.createHashRouter({});
            this.router.register(this.notify.bind(this));
            break;
          }
        }
        this.routes = this._initRoutes(this.routes);
        const currentPath = this.router.getPath();
        this.currentRoute =
          this.routes.find((route) => route.path === currentPath) || null;
      }

      mode = "hash";
      routes = [];
      // 当前路由
      currentRoute = null;
      router = null;
      deps = [];

      _initRoutes(routes) {
        function helper(children, parentRoute) {
          for (let i = 0; i < children.length; i++) {
            children[i] = new Route(children[i]);
            let v = children[i];

            // 如果子路由的 path 不以 / 开头
            if (!/^\//.test(v.path) && parentRoute) {
              v.path = `${parentRoute.path}/${v.path}`;
            }

            if (v.children && v.children.length) {
              helper(v.children, children[i]);
            }
          }
        }

        helper(routes, routes);
        return routes;
      }

      /**
       * 注册回调，当路由发生变化时触发
       **/
      depend(cb) {
        this.deps.push(cb);
      }

      /**
       * 当路由变化时执行回调
       **/
      notify() {
        this.deps.forEach((v) => v(this.currentRoute));
      }

      getRoutes() {
        return this.routes;
      }

      push(ops) {
        this.router.push(ops, (path) => {
          this.currentRoute = this.routes.find((v) => v.path === path) || null;
        });
      }

      hasRoute() {}

      go(num) {
        this.router.go(num, (path) => {
          this.currentRoute = this.routes.find((v) => v.path === path) || null;
        });
      }

      back() {
        this.go(-1);
      }

      forward() {
        this.go(1);
      }

      replace() {}

      beforeEach() {}
    }
    class Route {
      constructor(options) {
        for (const key in options) {
          if (this.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }

      path = "";
      children = [];
      name = "";
      beforeEnter = () => {};
      meta = {};
    }

    const router = new Router({
      mode: "hash",
      routes: [
        {
          path: "/home",
          component() {
            return `home page`;
          },
        },
        {
          path: "/about",
          component() {
            return `about page`;
          },
        },
        {
          path: "/category",
          component() {
            return `category page`;
          },
          children: [
            {
              path: "game",
              component() {
                return `category-game page`;
              },
            },
            {
              path: "sport",
              component() {
                return `category-sport page`;
              },
            },
          ],
        },
      ],
    });
    router.depend((route) => {
      console.log("route :>> ", route);
    });

    const routerItems = document.querySelectorAll(".router-item");
    routerItems.forEach((v) =>
      v.addEventListener("click", handleLinkClick, false)
    );

    function handleLinkClick(e) {
      if (e) {
        const target = e.target;
        const path = target.dataset.path;
        router.push({
          path,
        });
      }
    }
  </script>
</html>
