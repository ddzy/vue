<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>demo</title>
    <!-- Delete ".min" for console warnings in development -->
    <script src="../../dist/vue.js"></script>
    <style>
      html,
      body {
        height: 100%;
      }
      body,
      ul,
      li,
      p {
        margin: 0;
        padding: 0;
        list-style: none;
      }
      #wrapper {
        position: relative;
        width: 800px;
        margin: 0 auto;
      }
      img {
        position: absolute;
        transition: opacity 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <template id="appComponent">
      <div v-if="flag"></div>
    </template>
  </body>
  <script>
    const AppComponent = Vue.component("AppComponent", {
      template: "#appComponent",
      props: {
        flag: {
          type: Boolean,
          required: true,
        },
      },
    });
    const AppComponent2 = Vue.component("AppComponent2", {
      render(h) {
        return h(
          "div",
          {
            class: "app-2-container",
          },
          "5678"
        );
      },
    });
    const app = new Vue({
      el: "#app",
      template: `
        <div class="container">
          <app-component :flag="flag"></app-component>
          <button @click="flag = !flag">Toggle flag</button>
        </div>
      `,
      components: {
        AppComponent,
      },
      data() {
        return {
          firstName: "zhaoyang",
          lastName: "duan",
          flag: false,
        };
      },
      computed: {
        computedFlag() {
          return this.flag ? 1 : 0;
        },
        computedName() {
          return `${this.lastName} ${this.firstName}`;
        },
      },
    });
  </script>
  <script>
    // const vm = new Vue({
    //   el: ".wrapper",
    //   data() {
    //     return {
    //       data: this.getData(),
    //       screenHeight: window.innerHeight,
    //       positions: [],
    //       scrollTop: 0,

    //       initialItemHeight: 100,
    //     };
    //   },
    //   computed: {
    //     computedWrapper() {
    //       return this.$refs.wrapperRef;
    //     },
    //     computedList() {
    //       return this.$refs.listRef;
    //     },
    //     computedGhost() {
    //       return this.$refs.ghostRef;
    //     },
    //     computedItems() {
    //       return this.computedList ? this.computedList.children : [];
    //     },
    //     computedItemContents() {
    //       return this.computedList.querySelectorAll("p");
    //     },
    //     computedGhostHeight() {
    //       return this.positions[this.positions.length - 1].bottom;
    //     },
    //     computedStartIndex() {
    //       if (this.scrollTop === 0) {
    //         return 0;
    //       }
    //       const foundStart = this.positions.find(
    //         (v) => this.scrollTop >= v.bottom
    //       );
    //       return foundStart ? foundStart.index : 0;
    //     },
    //     computedEndIndex() {
    //       const foundEnd = this.positions.find(
    //         (v) =>
    //           v.bottom - this.positions[this.computedStartIndex].bottom >=
    //           this.screenHeight
    //       );

    //       return foundEnd ? foundEnd.index : 0;
    //     },
    //     computedFinalData() {
    //       return this.data.slice(
    //         this.computedStartIndex,
    //         this.computedEndIndex + 1
    //       );
    //     },
    //   },
    //   watch: {
    //     computedStartIndex(newStartIndex) {
    //       console.log("newStartIndex :>> ", newStartIndex);
    //     },
    //     computedEndIndex(newEndIndex) {
    //       console.log("newEndIndex :>> ", newEndIndex);
    //     },
    //   },
    //   methods: {
    //     getData() {
    //       const data = [];

    //       for (let i = 0; i < 1000; i++) {
    //         data.push({
    //           _id: i,
    //           value: `${i}-${String(i).repeat(
    //             Math.random() * (1000 - 800) + 50
    //           )}`,
    //         });
    //       }
    //       return data;
    //     },
    //     updatePositions() {
    //       [...this.computedItems].forEach((v) => {
    //       const index = Number(v.getAttribute("id"));
    //       const rect = v.getBoundingClientRect();
    //       const prevIndex = index - 1 < 0 ? 0 : index - 1;

    //       console.log('prevIndex :>> ', prevIndex);

    //       this.positions[index] = {
    //         ...this.positions[index],
    //         height: rect.height,
    //         // 上一个列表项的 bottom + 当前列表项的高度
    //         bottom: rect.bottom + this.positions[prevIndex].bottom,
    //         top: this.positions[prevIndex].bottom,
    //       };
    //     });
    //     },
    //   },
    //   created() {
    //     this.positions = this.data.map((v, index) => ({
    //       index,
    //       height: this.initialItemHeight,
    //       bottom: (index + 1) * this.initialItemHeight,
    //       top: index * this.initialItemHeight,
    //     }));
    //   },
    //   mounted() {
    //     this.computedWrapper.addEventListener("scroll", (e) => {
    //       this.scrollTop = e.currentTarget.scrollTop;
    //     });
    //     this.updatePositions();
    //   },
    //   updated() {
    //     this.updatePositions();
    //   },
    // });
  </script>
  <script>
    // const list = document.getElementById("list");
    // const wrapper = document.querySelector(".wrapper");
    // const ghost = document.querySelector("#ghost");
    // const content = document.querySelector(".item-content");

    // const data = getData();
    // // 每一项的预估高度
    // const itemHeight = 100;
    // // 可视区域的高度
    // const screenHeight = window.innerHeight;
    // // 每次渲染多少个
    // const groupSize = Math.ceil(screenHeight / itemHeight);
    // // 起始位置
    // let startIndex = 0;
    // // 最终位置
    // let endIndex =
    //   startIndex + groupSize <= data.length
    //     ? startIndex + groupSize - 1
    //     : data.length - 1;
    // // 存储列表每一项的真实高度
    // const positions = data.map((v, index) => {
    //   return {
    //     index,
    //     height: itemHeight,
    //     top: index * itemHeight,
    //     bottom: (index + 1) * itemHeight,
    //   };
    // });

    // function getData() {
    //   const data = [];

    //   for (let i = 0; i < 1000; i++) {
    //     data.push({
    //       _id: i,
    //       value: `${i}-${String(i).repeat(Math.random() * (1000 - 800) + 50)}`,
    //     });
    //   }
    //   return data;
    // }
    // function throttle(callback, timestamp) {
    //   let prevTime = Date.now();
    //   return function (...args) {
    //     let currentTime = Date.now();
    //     if (currentTime - prevTime >= timestamp) {
    //       callback.apply(this, args);
    //       prevTime = currentTime;
    //     }
    //   };
    // }
    // function render(start, end) {
    //   if (positions.length !== data.length) {
    //     // 把已经渲染出来的列表项的位置大小信息缓存起来
    //     const children = list.querySelectorAll(".item-content");
    //     for (let i = 0; i < children.length; i++) {
    //       const dom = children[i];
    //       const rect = dom.getBoundingClientRect();
    //       const pos = Number(dom.getAttribute("id"));
    //       positions[pos] = {
    //         ...positions[pos],
    //         height: rect.height,
    //         top: rect.top,
    //         bottom: rect.bottom,
    //       };
    //     }
    //   }

    //   const div = document.createElement("div");
    //   for (let i = start; i <= end; i++) {
    //     const li = document.createElement("li");
    //     const p = document.createElement("p");
    //     li.appendChild(p);
    //     li.setAttribute("id", data[i]._id);
    //     li.classList.add("item");
    //     p.classList.add("item-content");
    //     p.textContent = data[i].value;
    //     li.style.cssText += `height: ${positions[i] ? "auto" : itemHeight}px`;
    //     div.appendChild(li);
    //   }
    //   list.innerHTML = div.innerHTML;
    // }

    // // 第一次渲染
    // render(startIndex, endIndex);
    // // 监听滚动，滚动时动态计算起始和结束位置
    // wrapper.addEventListener("scroll", throttle(handleScroll, 10));

    // function handleScroll(e) {
    //   const scrollTop = this.scrollTop;
    //   // startIndex = Math.ceil(scrollTop / itemHeight);
    //   // endIndex =
    //   //   startIndex + groupSize <= data.length
    //   //     ? startIndex + groupSize - 1
    //   //     : data.length - 1;

    //   let newStartIndex = positions.find((v) => v.top <= 0);
    //   let newEndIndex = positions.find((v) => v.bottom <= 0);
    //   startIndex = newStartIndex ? newStartIndex.index + 1 : 0;
    //   endIndex = newEndIndex ? newEndIndex.index + 1 : 10;

    //   render(startIndex, endIndex);

    //   // 重新计算渲染区域的位置，避免被顶到上面去
    //   list.style.cssText += `
    //     transform: translate3d(0, ${scrollTop}px, 0)
    //   `;
    // }
  </script>
  <script>
    // 懒加载
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: this.fetchData(),
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const result = [];

    //       for (let i = 0; i < 50; i++) {
    //         result.push({
    //           _id: i,
    //           src: `http://iph.href.lu/100x100?text=${i}`,
    //           dataSrc:
    //             "https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg",
    //           width: 100,
    //           height: 100,
    //         });
    //       }

    //       return result;
    //     },
    //   },
    //   mounted() {
    //     const imgs = this.$refs.imgRef;
    //     const io = new IntersectionObserver(
    //       (entries) => {
    //         entries.forEach((entry) => {
    //           if (entry.isIntersecting) {
    //             entry.target.setAttribute(
    //               "src",
    //               entry.target.getAttribute("data-src")
    //             );
    //           }
    //         });
    //       },
    //       {
    //         threshold: 0.5,
    //       }
    //     );

    //     imgs.forEach((v) => {
    //       io.observe(v);
    //     });
    //   },
    // });
  </script>
  <script>
    // 瀑布流
    // const vm = new Vue({
    //   el: "#wrapper",
    //   data() {
    //     return {
    //       imgList: [],
    //       width: 150, // 固定宽度
    //       gap: 10, // 间隔
    //       columns: 1, // 列数
    //       columnsHeight: [], // 存储每一列的高度
    //       loadedImgCount: 0, // 记录当前已经加载完成的图片数量
    //     };
    //   },
    //   methods: {
    //     fetchData() {
    //       const data = [];

    //       for (let i = 0; i < 50; i++) {
    //         const height = Math.floor(Math.random() * (400 - 100) + 100);
    //         data.push({
    //           _id: i,
    //           src: `http://iph.href.lu/${this.width}x${height}?text=${i}`,
    //           width: this.width,
    //           height: 0,
    //           left: 0,
    //           top: 0,
    //           opacity: 0,
    //         });
    //       }

    //       return data;
    //     },
    //     imageLoaded(e) {
    //       this.loadedImgCount += 1;

    //       const img = e.target;
    //       const imgRect = img.getBoundingClientRect();
    //       const imgIndex = +img.dataset.index;

    //       // 第一行
    //       if (this.loadedImgCount <= this.columns) {
    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap,
    //           left: (this.width + this.gap) * (this.loadedImgCount - 1),
    //           opacity: 1,
    //         });
    //         this.columnsHeight[this.loadedImgCount - 1] =
    //           this.gap + imgRect.height;
    //       } else {
    //         // 其余行
    //         // 寻找最短的一列插入
    //         const minColumnHeight = Math.min(...this.columnsHeight);
    //         const minColumnIndex = this.columnsHeight.findIndex(
    //           (v) => v === minColumnHeight
    //         );

    //         this.$set(this.imgList, imgIndex, {
    //           ...this.imgList[imgIndex],
    //           height: imgRect.height,
    //           top: this.gap + minColumnHeight,
    //           left: (this.width + this.gap) * minColumnIndex,
    //           opacity: 1,
    //         });
    //         this.columnsHeight[minColumnIndex] += this.gap + imgRect.height;
    //       }
    //     },
    //   },
    //   created() {
    //     const data = this.fetchData();
    //     this.imgList = data;
    //   },
    //   mounted() {
    //     // 计算列数
    //     const wrapper = this.$refs.wrapperRef;
    //     const wrapperClientWidth = wrapper.clientWidth;
    //     this.columns = Math.floor(wrapperClientWidth / (this.width + this.gap));
    //     this.columnsHeight = new Array(this.columns).fill(0);
    //   },
    // });
  </script>
  <script>
    class _Promise {
      constructor(callback) {
        try {
          callback(this._resolve.bind(this), this._reject.bind(this));
        } catch (error) {
          this.exception = error;
          this._reject(error);
        }

        // 等待主线程收集完所有的 then/catch 回调之后，再决定是否直接抛出异常
        setTimeout(() => {
          if (this.exception !== undefined && !this.rejectList.length) {
            // 如果没有定义 catch 回调，那么直接抛出异常
            throw new Error(`Uncaught in promise: ${this.exception}`);
          }
        }, 0);
      }

      static resolve(value) {
        return new this((resolve) => {
          resolve(value);
        });
      }

      static reject(error) {
        return new this((resolve, reject) => {
          reject(error);
        });
      }

      static all(promiseList) {
        const result = [];
        let isExit = false;
        let count = 0;

        return new this((resolve, reject) => {
          for (let i = 0; i < promiseList.length; i++) {
            const v = promiseList[i];

            // 只要有一个 promise 为 rejected，那么直接终止循环
            if (isExit) {
              break;
            }
            // 如果是基本值
            if (!(v instanceof this)) {
              result[i] = v;
              count += 1;
            } else {
              // 如果是 Promise 实例
              v.then((res) => {
                // 多个 Promise 是依次执行的，无需等待，但是返回值的顺序还是按照传入的顺序
                result[i] = res;
                count += 1;

                if (count === promiseList.length) {
                  resolve(result);
                }
              }).catch((err) => {
                isExit = true;
                reject(err);
              });
            }
          }
        });
      }

      status = "pending";
      value = undefined;
      // 存储异常信息，便于直接抛出异常（Uncaught in promise xxx）
      exception = undefined;
      // 存储 then/reject 回调，解决非链式调用的情况（p.then1; p.then2）
      resolveList = [];
      rejectList = [];

      _resolve(value) {
        // 浏览器无法模拟微任务，所以使用Promise代替，目的是为了在 then 方法成功注册回调之后再执行
        Promise.resolve().then(() => {
          if (this.status === "pending") {
            this.value = value;
            this.status = "fulfilled";
            this.resolveList.forEach((v) => {
              let res;
              try {
                res = v.onFulfilled(this.value);
                v.nextResolve(res);
              } catch (e) {
                // 如果在执行 .then 回调的时候捕获到错误
                v.nextReject(e);
              }
            });
          }
        });
      }

      _reject(error) {
        Promise.resolve().then(() => {
          if (this.status === "pending") {
            this.value = error;
            this.status = "rejected";
            this.exception = error;

            this.rejectList.forEach((v) => {
              let res;
              try {
                let res = v.onRejected(this.value);
                v.nextResolve(res);
              } catch (e) {
                // 如果在执行 .catch 回调的时候捕获到错误
                v.nextReject(e);
              }
            });
          }
        });
      }

      then(onFulfilled, onRejected) {
        // 链式调用（p.then.then）
        return new _Promise((nextResolve, nextReject) => {
          // 执行 then 方法的时候，如果此时 promise 还没有返回值
          // 那么分别将回调加入到队列中，等待 resolve/reject 时执行
          if (this.status === "pending") {
            if (onFulfilled) {
              this.resolveList.push({
                onFulfilled,
                nextResolve,
                nextReject,
              });
            }
            if (onRejected) {
              this.exception = undefined;
              this.rejectList.push({
                onRejected,
                nextResolve,
                nextReject,
              });
            }
          } else if (this.status === "fulfilled") {
            // 如果 promise 已经有返回值，直接调用回调
            if (onFulfilled) {
              let res = onFulfilled(this.value);
              nextResolve(res);
            }
          } else if (this.status === "rejected") {
            // 如果 promise 已经有返回值，直接调用回调
            if (onRejected) {
              let res = onRejected(this.value);
              nextResolve(res);
            }
          }
        });
      }

      catch(onRejected) {
        return this.then(null, onRejected);
      }
    }

    let promise1 = new _Promise((resolve) => {
      setTimeout(() => {
        resolve(1);
      }, 1000);
    });
    let promise2 = new _Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(2);
      }, 500);
    });
    let promise3 = new _Promise((resolve, reject) => {
      resolve(3);
    });
    let promise4 = 4;

    _Promise.all([promise1, promise2, promise3, promise4]).then(
      (res) => {
        console.log("res :>> ", res);
      },
      (err) => {
        console.log("err :>> ", err);
      }
    );
  </script>
</html>
